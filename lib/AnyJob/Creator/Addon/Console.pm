package AnyJob::Creator::Addon::Console;

###############################################################################
# Addon that creates jobs using command-line of console application.
#
# Author:       LightStar
# Created:      29.11.2017
# Last update:  29.01.2019
#

use strict;
use warnings;
use utf8;

use JSON::XS;

use AnyJob::Constants::Delay;
use AnyJob::Constants::Events qw(EVENT_GET_DELAYED_WORKS);
use AnyJob::DateTime qw(formatDateTime);

use base 'AnyJob::Creator::Addon::Base';

###############################################################################
# Construct new AnyJob::Creator::Addon::Console object.
#
# Arguments:
#     parent - parent component which is usually AnyJob::Creator object.
# Returns:
#     AnyJob::Creator:Addon::Console object.
#
sub new {
    my $class = shift;
    my %args = @_;
    $args{type} = 'console';
    my $self = $class->SUPER::new(%args);
    return $self;
}

###############################################################################
# Do some action using command-line arguments.
# Either job or jobset is created, or some action with delayed work is performed.
# Internally AnyJob::Creator::Parser is used, so see there for details of parsing args.
#
# Arguments:
#     args - array of strings with command-line arguments.
# Returns:
#     reply string with error or success message.
#
sub run {
    my $self = shift;
    my $args = shift;

    my ($delay, $job, $errors);
    ($delay, $job, undef, $errors) = $self->parent->parse($args);
    unless (defined($delay) or defined($job)) {
        return 'Error: ' . (scalar(@$errors) > 0 ? $errors->[0]->{text} : 'unknown error');
    }

    $errors = [ grep {$_->{type} eq 'error'} @$errors ];
    if (scalar(@$errors) > 0) {
        return 'Error' . (scalar(@$errors) > 1 ? 's' : '') . ': ' . join(', ', map {$_->{text}} @$errors);
    }

    unless (defined($delay)) {
        return $self->createJob($job);
    } elsif ($delay->{action} eq DELAY_ACTION_CREATE) {
        return $self->delayJob($delay, $job);
    } elsif ($delay->{action} eq DELAY_ACTION_UPDATE) {
        return defined($job) ?
            $self->delayJob($delay, $job) :
            $self->updateDelayedWork($delay);
    } elsif ($delay->{action} eq DELAY_ACTION_DELETE) {
        return $self->deleteDelayedWork($delay);
    } elsif ($delay->{action} eq DELAY_ACTION_GET) {
        return $self->getDelayedWorks($delay);
    }
}

###############################################################################
# Create job using data parsed from command-line arguments.
#
# Arguments:
#     job - hash with job data generated by AnyJob::Creator::Parser module.
# Returns:
#     reply string with error or success message.
#
sub createJob {
    my $self = shift;
    my $job = shift;

    $self->debug('Create job using console creator: ' . encode_json($job));

    my $error = $self->parent->createJobs([ $job ], { author => 'console' });
    if (defined($error)) {
        $self->debug('Creating failed: ' . $error);
        return 'Error: ' . $error;
    }

    return 'Job created';
}

###############################################################################
# Delay job using data parsed from command-line arguments.
#
# Arguments:
#     delay - hash with delay data generated by AnyJob::Creator::Parser module.
#     job   - hash with job data generated by AnyJob::Creator::Parser module.
# Returns:
#     reply string with error or success message.
#
sub delayJob {
    my $self = shift;
    my $delay = shift;
    my $job = shift;

    $self->debug('Delay job using console creator: ' . encode_json($job) . ', delay: ' . encode_json($delay));

    if (exists($delay->{id})) {
        if (defined(my $error = $self->checkDelayedWork($delay->{id}))) {
            $self->debug('Delaying failed: ' . $error);
            return 'Error: ' . $error;
        }
    }

    my $error = $self->parent->delayJobs($delay, [ $job ], { author => 'console' });
    if (defined($error)) {
        $self->debug('Delaying failed: ' . $error);
        return 'Error: ' . $error;
    }

    return exists($delay->{id}) ? 'Delayed work updated' : 'Job delayed';
}

###############################################################################
# Update delayed work using data parsed from command-line arguments.
#
# Arguments:
#     delay - hash with delay data generated by AnyJob::Creator::Parser module.
# Returns:
#     reply string with error or success message.
#
sub updateDelayedWork {
    my $self = shift;
    my $delay = shift;

    $self->debug('Update delayed work using console creator: ' . encode_json($delay));

    if (defined(my $error = $self->checkDelayedWork($delay->{id}))) {
        $self->debug('Updating failed: ' . $error);
        return 'Error: ' . $error;
    }

    if (defined(my $error = $self->parent->checkDelay($delay))) {
        $self->debug('Updating failed: ' . $error);
        return 'Error: ' . $error;
    }

    $self->parent->updateDelayedWork($delay);

    return 'Delayed work updated';
}

###############################################################################
# Delete delayed work using data parsed from command-line arguments.
#
# Arguments:
#     delay - hash with delay data generated by AnyJob::Creator::Parser module.
# Returns:
#     reply string with error or success message.
#
sub deleteDelayedWork {
    my $self = shift;
    my $delay = shift;

    $self->debug('Delete delayed work using console creator: ' . encode_json($delay));

    if (defined(my $error = $self->checkDelayedWork($delay->{id}))) {
        $self->debug('Deleting failed: ' . $error);
        return 'Error: ' . $error;
    }

    $self->parent->deleteDelayedWork($delay->{id});

    return 'Delayed work removed';
}

###############################################################################
# Get delayed works using data parsed from command-line arguments.
#
# Arguments:
#     delay - hash with delay data generated by AnyJob::Creator::Parser module.
# Returns:
#     reply string with error or success message.
#
sub getDelayedWorks {
    my $self = shift;
    my $delay = shift;

    $self->debug('Get delayed works using console creator: ' . encode_json($delay));

    my ($works, $error) = $self->getDelayedWorksById($delay->{id});
    if (defined($error)) {
        $self->debug('Get failed: ' . $error);
        return 'Error: ' . $error;
    }

    return $self->formatDelayedWorks($works);
}

###############################################################################
# Represent array of delayed works as joined string lines. Return special string in case when array is empty.
#
# Arguments:
#    works - array of hashes containing delayed works data.
# Returns:
#    string with formatted delayed works.
#
sub formatDelayedWorks {
    my $self = shift;
    my $works = shift;

    if (scalar(@$works) == 0) {
        return 'No delayed works';
    }

    my @workLines;
    foreach my $work (@$works) {
        my $line = $work->{id} . '. ' . $work->{summary} . ' (' .
            (defined($work->{time}) ? formatDateTime($work->{time}) : '') .
            (defined($work->{crontab}) ? $work->{crontab} .
                ($work->{skip} > 0 ? ', skip: ' . $work->{skip} : '') .
                ($work->{pause} ? ', paused' : '') : '') .
            ')' . ' - created by \'' . $work->{props}->{author} . '\' at ' . formatDateTime($work->{props}->{time});
        push @workLines, $line
    }

    return join("\n", @workLines);
}

###############################################################################
# Check that delayed work with specified id exists.
#
# Arguments:
#     id - integer delayed work id.
# Returns:
#     undef if delayed work was found or string error message.
#
sub checkDelayedWork {
    my $self = shift;
    my $id = shift;

    my ($works, $error) = $self->getDelayedWorksById($id);
    if (defined($error)) {
        return $error;
    }

    if (scalar(@$works) != 1) {
        return 'delayed work not found';
    }

    return undef;
}

###############################################################################
# Get all delayed works or just one with specified id.
#
# Arguments:
#     id - optional integer delayed work id or undef.
# Returns:
#     array of hashes with delayed works data or undef.
#     string error message or undef.
#
sub getDelayedWorksById {
    my $self = shift;
    my $id = shift;

    $self->parent->redis->del('anyjob:observerq:private:console');
    $self->parent->getDelayedWorks('console', $id);

    my $response;
    (undef, $response) = $self->parent->redis->blpop('anyjob:observerq:private:console', DELAY_GET_TIMEOUT);
    unless (defined($response)) {
        return +(undef, 'get timeout reached');
    }

    my $event;
    eval {
        $event = decode_json($response);
    };
    if ($@) {
        return +(undef, 'get response is not valid json: ' . $response);
    }

    if ($event->{event} ne EVENT_GET_DELAYED_WORKS) {
        return +(undef, 'get response event does not have valid type: ' . $response);
    }

    return +($event->{works}, undef);
}

1;
