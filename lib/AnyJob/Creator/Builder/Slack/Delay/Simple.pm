package AnyJob::Creator::Builder::Slack::Delay::Simple;

###############################################################################
# Slack builder used to delay job or perform some operation with delayed work using slash command's text.
#
# Author:       LightStar
# Created:      06.12.2018
# Last update:  16.12.2018
#

use strict;
use warnings;
use utf8;

use JSON::XS;

use AnyJob::Constants::Events qw(EVENT_STATUS EVENT_GET_DELAYED_WORKS);
use AnyJob::Constants::Delay;

use base 'AnyJob::Creator::Builder::Slack::Simple';

###############################################################################
# Handle slack slash command. Text is parsed by AnyJob::Creator::Parser module so look there for details.
# Job is delayed (or operation with delayed work is processed) only if AnyJob::Creator::Parser returns no errors
# (warnings are permitted).
#
# Arguments:
#     text        - string command text.
#     userId      - string user id.
#     responseUrl - string response url.
#     triggerId   - string trigger id.
#     userName    - string user name.
# Returns:
#     string result to show user or undef.
#
sub command {
    my $self = shift;
    my $text = shift;
    my $userId = shift;
    my $responseUrl = shift;
    my $triggerId = shift;
    my $userName = shift;

    my ($delay, $job, $errors);
    ($delay, $job, undef, $errors) = $self->parent->parse($text, undef, { delay => 1 });
    unless (defined($delay)) {
        return 'Error: ' . (scalar(@$errors) > 0 ? $errors->[0]->{text} : 'unknown error');
    }

    if ((defined($job) and not $self->parentAddon->checkJobAccess($userId, $job)) or
        not $self->parentAddon->checkDelayAccess($userId, $delay, $job)
    ) {
        return 'Error: access denied';
    }

    if (defined(my $parseErrors = $self->checkParseErrors($errors))) {
        return $parseErrors;
    }

    if ($delay->{action} eq DELAY_ACTION_UPDATE or $delay->{action} eq DELAY_ACTION_DELETE) {
        $self->createGetDelayedWorkBuild($delay, $job, $userId, $responseUrl, $triggerId, $userName);
        return undef;
    } elsif ($delay->{action} eq DELAY_ACTION_CREATE) {
        return $self->delayJob($delay, $job, $responseUrl, $userName);
    } elsif ($delay->{action} eq DELAY_ACTION_GET) {
        return $self->getDelayedWorks($delay, $responseUrl, $userName, $userId);
    }

    return 'Error: unknown error';
}

###############################################################################
# Method which will be called when new service event arrives.
#
# Arguments:
#     event - hash with event data.
#
sub receiveServiceEvent {
    my $self = shift;
    my $event = shift;

    if ($event->{event} eq EVENT_STATUS) {
        $self->sendResponse({ text => $event->{message} }, $event->{props}->{response_url});
    } elsif ($event->{event} eq EVENT_GET_DELAYED_WORKS) {
        $self->continueDelayedWorkAction($event);
    }
}

###############################################################################
# Continue update or delete operation.
#
# Arguments:
#     event - hash with event data.
#
sub continueDelayedWorkAction {
    my $self = shift;
    my $event = shift;

    my ($id, $build);
    (undef, $id) = split(/:/, $event->{props}->{service});
    unless (defined($id) and defined($build = $self->getBuild($id))) {
        return;
    }

    my $response = undef;
    if (scalar(@{$event->{works}}) != 1) {
        $response = 'Error: delayed work not found';
    } else {
        my $action = $build->{delay}->{action};
        my $work = $event->{works}->[0];

        unless ($self->parentAddon->checkDelayedWorkAccess($build->{userId}, $action, $work)) {
            $response = 'Error: access denied';
        } elsif ($action eq DELAY_ACTION_UPDATE) {
            $response = $self->delayJob($build->{delay}, $build->{job}, $build->{responseUrl}, $build->{userName},
                $work->{update});
        } elsif ($action eq DELAY_ACTION_DELETE) {
            $response = $self->deleteDelayedWork($build->{delay}, $build->{responseUrl}, $build->{userName},
                $work->{update});
        }
    }

    $self->cleanBuild($id);

    if (defined($response)) {
        $self->sendResponse({ text => $response }, $build->{responseUrl});
    }
}

###############################################################################
# Delay job using data parsed from input arguments.
#
# Arguments:
#     delay       - hash with delay data generated by AnyJob::Creator::Parser module.
#     job         - hash with job data generated by AnyJob::Creator::Parser module.
#     responseUrl - string response url.
#     userName    - string user name.
#     updateCount - update count which must be checked for permanence before updating.
# Returns:
#     reply string with error or success message.
#
sub delayJob {
    my $self = shift;
    my $delay = shift;
    my $job = shift;
    my $responseUrl = shift;
    my $userName = shift;
    my $updateCount = shift;

    my $opts = undef;
    if (exists($delay->{id}) and defined($updateCount)) {
        $opts = {
            check_update   => $updateCount,
            status_service => $self->name
        };
    }

    my $error = $self->parent->delayJobs($delay, [ $job ], {
        creator      => 'slack',
        author       => $userName,
        observer     => 'slack',
        response_url => $responseUrl
    }, $opts);

    if (defined($error)) {
        $self->debug('Delaying failed: ' . $error);
        return 'Error: ' . $error;
    }

    if (exists($delay->{id}) and defined($updateCount)) {
        return undef;
    }

    return exists($delay->{id}) ? 'Delayed work updated' : 'Job delayed';
}

###############################################################################
# Delete delayed work using data parsed from input arguments.
#
# Arguments:
#     delay       - hash with delay data generated by AnyJob::Creator::Parser module.
#     responseUrl - string response url.
#     userName    - string user name.
#     updateCount - update count which must be checked for permanence before deleting.
# Returns:
#     reply string with error or success message.
#
sub deleteDelayedWork {
    my $self = shift;
    my $delay = shift;
    my $responseUrl = shift;
    my $userName = shift;
    my $updateCount = shift;

    my $opts = undef;
    if (defined($updateCount)) {
        $opts = {
            check_update   => $updateCount,
            status_service => $self->name
        };
    }

    $self->parent->deleteDelayedWork($delay->{id}, {
        creator      => 'slack',
        author       => $userName,
        observer     => 'slack',
        response_url => $responseUrl
    }, $opts);

    if (defined($updateCount)) {
        return undef;
    }

    return 'Delayed work removed';
}

###############################################################################
# Retrieve delayed works using data parsed from input arguments.
#
# Arguments:
#     delay       - hash with delay data generated by AnyJob::Creator::Parser module.
#     responseUrl - string response url.
#     userName    - string user name.
#     userId      - string user id.
# Returns:
#     reply string with error or result message.
#
sub getDelayedWorks {
    my $self = shift;
    my $delay = shift;
    my $responseUrl = shift;
    my $userName = shift;
    my $userId = shift;

    $self->parent->getDelayedWorks('slack', $delay->{id}, {
        creator      => 'slack',
        author       => $userName,
        response_url => $responseUrl,
        user         => $userId
    });

    return undef;
}

1;
